<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  The Trapped Knight · Michael Haneman
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Michael Haneman">
<meta name="description" content="
  Introduction
  
    
    Link to heading
  

Not too long ago while browsing, The Youtbe aglorithm blessed me with a Numberphile video called &ldquo;The Trapped Knight&rdquo;. Given simple rules for how a knight moves on a chess board, some intersting chaotic, patterns emerge.


    
    
      
    


  Rules Summary
  
    
    Link to heading
  


Suppose an infinitly large chessboard. Give a square a numeric value of 1. This square will be the point of origin.
From this origin, the rest of the real, positive integers will be put on the remaining squares in a spiral shape.
The knight will begin its journey at the origin
The knight will continouly move to the square with the lowest value that has not been visited yet

(insert manim graph)">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="The Trapped Knight">
  <meta name="twitter:description" content="Introduction Link to heading Not too long ago while browsing, The Youtbe aglorithm blessed me with a Numberphile video called “The Trapped Knight”. Given simple rules for how a knight moves on a chess board, some intersting chaotic, patterns emerge.
Rules Summary Link to heading Suppose an infinitly large chessboard. Give a square a numeric value of 1. This square will be the point of origin. From this origin, the rest of the real, positive integers will be put on the remaining squares in a spiral shape. The knight will begin its journey at the origin The knight will continouly move to the square with the lowest value that has not been visited yet (insert manim graph)">

<meta property="og:url" content="http://localhost:1313/posts/trapped-knight/">
  <meta property="og:site_name" content="Michael Haneman">
  <meta property="og:title" content="The Trapped Knight">
  <meta property="og:description" content="Introduction Link to heading Not too long ago while browsing, The Youtbe aglorithm blessed me with a Numberphile video called “The Trapped Knight”. Given simple rules for how a knight moves on a chess board, some intersting chaotic, patterns emerge.
Rules Summary Link to heading Suppose an infinitly large chessboard. Give a square a numeric value of 1. This square will be the point of origin. From this origin, the rest of the real, positive integers will be put on the remaining squares in a spiral shape. The knight will begin its journey at the origin The knight will continouly move to the square with the lowest value that has not been visited yet (insert manim graph)">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-05T15:58:27-07:00">
    <meta property="article:modified_time" content="2024-05-05T15:58:27-07:00">
    <meta property="article:tag" content="Python">
    <meta property="article:tag" content="Manim">
    <meta property="article:tag" content="Matplotlib">




<link rel="canonical" href="http://localhost:1313/posts/trapped-knight/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.css" media="screen">
  



 




<link rel="icon" type="image/svg+xml" href="/img/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/img/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/img/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      Michael Haneman
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/projects/">Projects</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/trapped-knight/">
              The Trapped Knight
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-05-05T15:58:27-07:00">
                May 5, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              5-minute read
            </span>
          </div>
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/michael-haneman/">Michael Haneman</a></div>

          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/simulation/">Simulation</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/python/">Python</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/manim/">Manim</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/tags/matplotlib/">Matplotlib</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="introduction">
  Introduction
  <a class="heading-link" href="#introduction">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>Not too long ago while browsing, The Youtbe aglorithm blessed me with a Numberphile video called &ldquo;The Trapped Knight&rdquo;. Given simple rules for how a knight moves on a chess board, some intersting chaotic, patterns emerge.</p>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/RGQe8waGJ4w?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h1 id="rules-summary">
  Rules Summary
  <a class="heading-link" href="#rules-summary">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<ol>
<li>Suppose an infinitly large chessboard. Give a square a numeric value of 1. This square will be the point of origin.</li>
<li>From this origin, the rest of the real, positive integers will be put on the remaining squares in a spiral shape.</li>
<li>The knight will begin its journey at the origin</li>
<li>The knight will continouly move to the square with the lowest value that has not been visited yet</li>
</ol>
<p>(insert manim graph)</p>
<p>For generating the spiral shape, two decisions have to be made. Firstly, which square from the origin will be visited next: top, bottom, left, or right square? Secondly, which direction will the spiral be generated: clockwise or counter clockwise? Ultimatly, these decisions are abritrary because changing these conditions will only create reflections and rotations in the final graph. The general shape and logic are not dependent on the inital conditions for the spiral. However to match the results found in the video, the first square from the origin will start on the square below and the spiral will continue counter-clockwise.</p>
<h1 id="result">
  Result
  <a class="heading-link" href="#result">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ZXOjEcl4wm4?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<h1 id="a-tour-of-the-code">
  A Tour of the Code
  <a class="heading-link" href="#a-tour-of-the-code">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="generating-the-spiral">
  Generating the Spiral
  <a class="heading-link" href="#generating-the-spiral">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>To Generate the spiral, we will keep track of a 2d vector that rotates 90 degrees after it has moved m (the length of the side of the spiral) squares.
The number of squares the vector will move will be m+1 after 2 rotations.
Technically, the logic to generate the spiral would need to run indefinatly to garentee sufficiency for the simulation.
But, we will artifically cap the size of the sprial at <code>spiral_size</code>.
If the simulation runs out of squares, the simulation will need to run again with a higher cap size.</p>
<p>Clearly, artifically capping the spiral size is not ideal.
What if the simulation has a large number of steps and needs to run for a long time?
Can&rsquo;t we have an algorithm to determine the number of squares needed?
This in itself is an interesting statistical problem.
What area of valued squares are needed to garentee the knight is able to move n times?
However in practice, the path of the knight tends to tighly wrap around the origin, making this problem unlikely and therefore ignored.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">gen_spiral</span>(self, spiral_size, negate_primes):
</span></span><span style="display:flex;"><span>        square_length <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>        dir <span style="color:#ff7b72;font-weight:bold">=</span> [<span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">1</span>]
</span></span><span style="display:flex;"><span>        current_square <span style="color:#ff7b72;font-weight:bold">=</span> [<span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        current_value <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> _ <span style="color:#ff7b72;font-weight:bold">in</span> range(<span style="color:#a5d6ff">0</span>, spiral_size):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">for</span> _ <span style="color:#ff7b72;font-weight:bold">in</span> range(<span style="color:#a5d6ff">0</span>, <span style="color:#a5d6ff">2</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">for</span> _ <span style="color:#ff7b72;font-weight:bold">in</span> range(<span style="color:#a5d6ff">0</span>, square_length):
</span></span><span style="display:flex;"><span>                    self<span style="color:#ff7b72;font-weight:bold">.</span>coord_vals[tuple(current_square)] <span style="color:#ff7b72;font-weight:bold">=</span> current_value
</span></span><span style="display:flex;"><span>                    current_square <span style="color:#ff7b72;font-weight:bold">=</span> [sum(i) <span style="color:#ff7b72">for</span> i <span style="color:#ff7b72;font-weight:bold">in</span> zip(current_square, dir)]
</span></span><span style="display:flex;"><span>                    current_value <span style="color:#ff7b72;font-weight:bold">+=</span> <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>                dir <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>rot_vec2_90(dir)
</span></span><span style="display:flex;"><span>            square_length <span style="color:#ff7b72;font-weight:bold">+=</span> <span style="color:#a5d6ff">1</span>
</span></span></code></pre></div><h2 id="moving-the-knight-and-checking-visited-squares">
  Moving the knight and checking visited squares
  <a class="heading-link" href="#moving-the-knight-and-checking-visited-squares">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>We will have a base class called Knight. But why? Why not just implement everything in the knight class? In the future, we may want to create new rules to apply to the knight. So, for each implementation of these rules, the Knight class will be inherited and the abstract method <code>find_next_square</code> will be implemented. In this way, each implementation is organized in each class and we will not have to duplicate setup code.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">Knight</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> __init__(self, start_pos: tuple <span style="color:#ff7b72;font-weight:bold">=</span> (<span style="color:#a5d6ff">0</span>,<span style="color:#a5d6ff">0</span>)) <span style="color:#ff7b72;font-weight:bold">-&gt;</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>curr_pos <span style="color:#ff7b72;font-weight:bold">=</span> start_pos
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>move_offsets <span style="color:#ff7b72;font-weight:bold">=</span> [(<span style="color:#a5d6ff">1</span>, <span style="color:#a5d6ff">2</span>), (<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>, <span style="color:#a5d6ff">2</span>), (<span style="color:#a5d6ff">1</span>, <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">2</span>), (<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>, <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">2</span>), (<span style="color:#a5d6ff">2</span>, <span style="color:#a5d6ff">1</span>), (<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">2</span>, <span style="color:#a5d6ff">1</span>), (<span style="color:#a5d6ff">2</span>, <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>), (<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">2</span>, <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>)]
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>pos_history <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span></code></pre></div><p>Lets implement the rules for finding the next square in a class called <code>NKnight</code>. Its called NKnight because n represents the nth lowest value the knight will go to (variations of this simulation will be created &hellip; for future posts). For example, if n=0 and we have the possible square values <code>[2, 9, 5]</code>, the knight will go to the square wil value 2. For n=1, the knight will go to the square with value 5. n=3, square with value 9. n=4, since there are only three options, we must take the square with value 9.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">class</span> <span style="color:#f0883e;font-weight:bold">NKnight</span>(Knight):
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> __init__(self, n<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">0</span>, start_pos: tuple <span style="color:#ff7b72;font-weight:bold">=</span> (<span style="color:#a5d6ff">0</span>,<span style="color:#a5d6ff">0</span>)) <span style="color:#ff7b72;font-weight:bold">-&gt;</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>        Knight<span style="color:#ff7b72;font-weight:bold">.</span>__init__(self, start_pos)
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>n <span style="color:#ff7b72;font-weight:bold">=</span> n
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">find_next_square</span>(self, coord_vals: Dict[tuple, int])<span style="color:#ff7b72;font-weight:bold">-&gt;</span> Optional[tuple]:
</span></span><span style="display:flex;"><span>    <span style="color:#ff7b72;font-weight:bold">...</span>
</span></span></code></pre></div><p>First, lets collect all the possible squares the knight can go to.</p>
<p>The intuative approach to marking visited squares will be to have a list of coordinates. Each time the knight moves to a new square, the coordinate is appended to this list. The problem with this approach is, everytime we check if a square is visited, validating if the value is in this list is an O(n) time complexity and O(n) memory. For example, if the knight is on move 10,000 and the next lowest valid square needs to be found. For each of the eight possible knight moves, we need to check if that specific coordinate exist inside of this list. In total, 80,000 list elements need to be checked.</p>
<p>Another approach would be to create a hashmap of all the visited squares as tuple keys. Therefore lookup will be O(1).
However, let&rsquo;s save a little extra memory. If a square when visited, the value will be negated. Therefore, for each lookup of the eight squares, we just need to check that it is greater than zero.</p>
<p>For the future variations, it&rsquo;s probably nessisary to keep a hashmap of visited squares. But, this will due for now.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">find_next_square</span>(self, coord_vals: Dict[tuple, int])<span style="color:#ff7b72;font-weight:bold">-&gt;</span> Optional[tuple]:
</span></span><span style="display:flex;"><span>        visited <span style="color:#ff7b72;font-weight:bold">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> offset <span style="color:#ff7b72;font-weight:bold">in</span> self<span style="color:#ff7b72;font-weight:bold">.</span>move_offsets:
</span></span><span style="display:flex;"><span>            pot_pos <span style="color:#ff7b72;font-weight:bold">=</span> tuple(map(<span style="color:#ff7b72">lambda</span> i, j: i <span style="color:#ff7b72;font-weight:bold">+</span> j, offset, self<span style="color:#ff7b72;font-weight:bold">.</span>curr_pos))
</span></span><span style="display:flex;"><span>            pot_val <span style="color:#ff7b72;font-weight:bold">=</span> coord_vals[pot_pos]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> pot_val <span style="color:#ff7b72;font-weight:bold">&gt;</span> <span style="color:#a5d6ff">0</span>:
</span></span><span style="display:flex;"><span>                visited<span style="color:#ff7b72;font-weight:bold">.</span>append((pot_pos, pot_val))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> len(visited) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">None</span>
</span></span></code></pre></div><p>This is the logic for calculating each step of the knight moves. Notice how we will return False when the knight is trapped.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ff7b72">def</span> <span style="color:#d2a8ff;font-weight:bold">calc_move</span>(self) <span style="color:#ff7b72;font-weight:bold">-&gt;</span> bool:
</span></span><span style="display:flex;"><span>        next_pos <span style="color:#ff7b72;font-weight:bold">=</span> self<span style="color:#ff7b72;font-weight:bold">.</span>knight<span style="color:#ff7b72;font-weight:bold">.</span>find_next_square(self<span style="color:#ff7b72;font-weight:bold">.</span>board<span style="color:#ff7b72;font-weight:bold">.</span>coord_vals)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">if</span> next_pos <span style="color:#ff7b72;font-weight:bold">is</span> <span style="color:#79c0ff">None</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>board<span style="color:#ff7b72;font-weight:bold">.</span>coord_vals[next_pos] <span style="color:#ff7b72;font-weight:bold">*=</span> <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span> <span style="color:#8b949e;font-style:italic"># update board</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">True</span>
</span></span></code></pre></div><p>Next, lets sort the array of avaliable squares by value. We want the lowest value squares so that way we can treat this list like a stack an pop off the lowest value form the end.</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>        visited<span style="color:#ff7b72;font-weight:bold">.</span>sort(reverse<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#79c0ff">True</span>, key<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#ff7b72">lambda</span> e: e[<span style="color:#a5d6ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">for</span> _ <span style="color:#ff7b72;font-weight:bold">in</span> range(self<span style="color:#ff7b72;font-weight:bold">.</span>n):
</span></span><span style="display:flex;"><span>            <span style="color:#ff7b72">if</span> (len(visited) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">1</span>):
</span></span><span style="display:flex;"><span>                <span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>            visited<span style="color:#ff7b72;font-weight:bold">.</span>pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result <span style="color:#ff7b72;font-weight:bold">=</span> visited<span style="color:#ff7b72;font-weight:bold">.</span>pop()[<span style="color:#a5d6ff">0</span>]
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>curr_pos <span style="color:#ff7b72;font-weight:bold">=</span> result
</span></span><span style="display:flex;"><span>        self<span style="color:#ff7b72;font-weight:bold">.</span>pos_history<span style="color:#ff7b72;font-weight:bold">.</span>append(result)
</span></span><span style="display:flex;"><span>        <span style="color:#ff7b72">return</span> result
</span></span></code></pre></div><p>Link to source code on github:
<a href="https://github.com/mhaneman/trapped-knight/tree/main"  class="external-link" target="_blank" rel="noopener">https://github.com/mhaneman/trapped-knight/tree/main</a></p>

      </div>


      <footer>
        


        
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2024
     Michael Haneman 
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
